# Learn.Javascript

### Типы данных
 - Число «number»
 - Строка «string»
 - Булевый (логический) тип «boolean»
 - Специальное значение «null»
 - Специальное значение «undefined»
 - Объекты «object» (массивы это тоже объекты)

Первые 5 типов называют «примитивными».
Особняком стоит шестой тип: «объекты».

**Важно:**
Оператор «Плюс». Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке.
Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.
Для преобразование к числу, часто используют унарный плюс +. При этом, если строка не является в точности числом, то результат будет NaN, единственное исключение – пробельные символы в начале и в конце строки, которые игнорируются.
```javascript
alert( +"12test" ); // NaN
alert( +"  -12" ); // -12
alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
alert( +"" ); // 0, пустая строка становится нулем
alert( +"1 2" ); // NaN, пробел посередине числа - ошибка
```

**Сравнение**
 - Строки сравниваются побуквенно.
 - Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства === (!==).
 - Значения null и undefined равны == друг другу и не равны ничему другому. В других сравнениях (с участием >,<) их лучше не использовать, так как они ведут себя не как 0.
 - При преобразовании в число null становится 0, а undefined становится NaN.
[Подробнее про сравнение undefined и null](https://learn.javascript.ru/comparison#%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81-null-%D0%B8-undefined)

Бывает, что числа приходят в скрипт в виде строк, например как результат prompt. В этом случае результат их сравнения будет неверным:
```javascript
// true, так как это строки, и для первых символов верно "2" > "1"
 alert( "2" > "14" );
// Если хотя бы один аргумент – не строка, то другой будет преобразован к числу:
 alert( 2 > "14" ); // false
```
**Округление**
*Math.floor* - Округляет вниз
*Math.ceil* - Округляет вверх
*Math.round* - Округляет до ближайшего целого
Битовые операторы делают любое число 32-битным целым, обрезая десятичную часть.
В результате побитовая операция, которая не изменяет число, например, двойное битовое НЕ – округляет его:
```javascript
alert( ~~12.3 ); // 12
alert( 12.3 ^ 0 ); // 12
alert( 1.2 + 1.3 ^ 0 ); // 2, приоритет ^ меньше, чем +
```
### Преобразование типов
 - Строка. Пробельные символы по краям обрезаются.
Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.
 - Преобразование к числу: +true 

### Работа со строками
Доступ к символам:
Разница между [] и charAt заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined
```javascript
alert( "".charAt(0) ); // пустая строка
alert( "" [0] ); // undefined
```
Красивое использование indexOf
```javascript
if ( ~str.indexOf(...) ) {}
```

### Объекты
Разница между проверками in и === undefined
Есть два средства для проверки наличия свойства в объекте: первое – оператор in, второе – получить его и сравнить с undefined. Они почти идентичны, но есть одна небольшая разница.
Дело в том, что технически возможно, что свойство есть, а его значением является undefined:
```javascript
var obj = {};
obj.test = undefined; // добавили свойство со значением undefined
// проверим наличие свойств test и заведомо отсутствующего blabla
alert( obj.test === undefined ); // true
alert( obj.blabla === undefined ); // true
```

### Функции
 - Функция может обратиться ко внешней переменной, но доступ возможен не только на чтение, но и на запись.
 - Если `return;` вызван без значения, или функция завершилась без `return`, то её результат равен `undefined`.
 - создание функций "на лету": ``var sum = new Function('a,b', 'return a+b;');``

Классическое» объявление функции, о котором мы говорили до этого, вида function имя(параметры) {...}, называется в спецификации языка «Function Declaration».
Существует альтернативный синтаксис для объявления функции, который ещё более наглядно показывает, что функция – это всего лишь разновидность значения переменной. Он называется «Function Expression» (функциональное выражение) и выглядит так:
 ```javascript
 var f = function(параметры) {
  // тело функции
};
```
!!! **Важно**: Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода. !!!
```javascript
sayHi("Вася"); // ошибка!
var sayHi = function(name) {
  alert( "Привет, " + name );
}
```

### Особенности из разных разделов
 - Максимальная глубина рекурсии в браузерах ограничена, точно можно рассчитывать на 10000 вложенных вызовов, но некоторые интерпретаторы допускают и больше.
 - [Именнованые функциональные выражения](https://learn.javascript.ru/named-function-expression)
 - [Неточные вычисления](https://learn.javascript.ru/number#netochnye-vychisleniya)

Любая часть for может быть пропущена.
 ```javascript
var i = 0;
for (; i < 3; i++) {
  alert( i ); // 0, 1, 2
}
```
или

```javascript
var i = 0;
for (; i < 3;) {
  alert( i );
  // цикл превратился в аналог while (i<3)
}
```

### async/defer
**Атрибут async**
Поддерживается всеми браузерами, кроме IE9-. Скрипт выполняется полностью асинхронно. 

**Атрибут defer**
Поддерживается всеми браузерами, включая самые старые IE. Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от async:
- браузер гарантирует, что относительный порядок скриптов с defer будет сохранён.
- скрипт с defer сработает, когда весь HTML-документ будет обработан браузером.
 
При одновременном указании async и defer в современных браузерах будет использован только async, в IE9- – только defer (не понимает async).

### Современный стандарт, "use strict"
```javascript
"use strict";
// этот код будет работать по современному стандарту ES5
```
В старом стандарте JavaScript разрешалось создавать переменную и без var, просто присвоив ей значение.

### Примечания
**Ошибка в IE8- без var**
Следущий документ в IE8- ничего не выведет, будет ошибка:
```javascript
<div id="test"></div>
<script>
  test = 5; // здесь будет ошибка!
  alert( test ); // не сработает
</script>
```
Это потому, что переменная test не объявлена через var и совпадает с id элемента <div>. Самое «забавное» то, что такая ошибка присвоения значений будет только в IE8- и только если на странице присутствует элемент с id, совпадающим с именем переменной.

**Область видимости в функциях**
```javascript
function showMessage() {
  message = 'Привет'; // без var!
}
showMessage();
alert( message ); // Привет
```